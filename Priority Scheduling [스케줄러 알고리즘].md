## Priority Scheduling [스케줄러 알고리즘]

우선순위 알고리즘은 말 그대로 작업 하나하나에 우선순위를 두어서,
우선순위가 높은 순서대로 작업을 실행하는 알고리즘이다.

기존의 FCFS는 먼저 들어온 작업이 우선순위에 관계없이 먼저 실행되도록 짜여진 알고리즘이었다.
그래서 만약 빨리 끝나는 작업인데도 불구하고 먼저 들어온 작업이 많거나
앞에 들어온 작업의 길이가 길다면 오래 대기 시간을 가져야 한다는 단점이 있었다.
그래서 우선순위 알고리즘은 이 단점을 보안해서 각각의 작업에 우선순위를 두는 방식을 채택하였다.

우선순위 알고리즘은 비선점형과 선점형으로 나누어서 살펴볼 수 있는데
각각 살펴보도록하자.

### 1. 우선순위 스케줄러 알고리즘

먼저 예시를 한 번 보고 그에 따른 장점과 단점에 대해서 알아보도록 하자.

| 프로세스이름 | 실행시간 | 우선순위 |
| :----------: | :------: | :------: |
|      A       |    10    |    3     |
|      B       |    1     |    1     |
|      C       |    2     |    3     |
|      D       |    1     |    4     |
|      E       |    5     |    2     |

만약 위와 같이 프로세스 - 실행시간 - 우선순위로 만들어진 준비 큐(Ready Queue)가 존재한다면
우리는 다음과 같이 프로세스가 CPU에게 할당을 받는 시간을 나타낸 간트차트를 만들 수 있다.
![OS_Study_Image3](./img/OS_Study_Image3.jpg)

이렇게 간트차트로 살펴보면 각각의 프로세스의 대기시간과 반환시간을 알아내기 쉽다는 장점이 있다.
또한 위의 준비 큐처럼 도착시간이 적혀있지 않은 경우에는 모두 0초에 도착한다는 것을 알고 있어야 한다.

그럼 프로세스 A부터 대기시간과 도착시간을 알아보면 다음과 같다.

```java
이름        대기시간  반환시간
프로세스 A   6초      16초
프로세스 B   0초      1초
프로세스 C   16초     18초
프로세스 D   18초     19초
프로세스 E   1초      6초
```

이런 비선점형 우선순위 스케줄러 알고리즘은
어느정도 공정성을 부여할 순 있지만 우선순위를 부여하는 과정에서 연산이 많아져, 오버헤드가 발생하게 된다.
그리고 우선순위가 낮은 프로세스는 오랫동안 기아상태에 빠진다는 단점이 존재한다.

### 2. 순차적으로 도착하는 우선순위 스케줄링

위의 1번에서는 도착시간이 존재하지 않는 스케줄링을 다뤘었다.
이번에는 순차적으로 도착하도록 도착시간이 지정되어 있고
우선순위 스케줄링 알고리즘으로 준비 큐를 사용하는 방법에 대해서 알아보도록 하겠다.

우선순위 스케줄링은 비선점형과 선점형으로 나눌 수 있는데
각각의 특징과 장단점이 존재한다.

#### 2-1. 비선점형 우선순위 스케줄링

먼저 비선점형 우선순위 스케줄링의 준비 큐는 다음과 같다.

| 프로세스이름 | 도착시간 | 실행시간 | 우선순위 |
| :----------: | :------: | :------: | :------: |
|      A       |    0     |    3     |    3     |
|      B       |    0     |    5     |    1     |
|      C       |    0     |    1     |    4     |
|      D       |    5     |    2     |    2     |
|      E       |    7     |    2     |    3     |
|      F       |    9     |    2     |    2     |
|      G       |    12    |    5     |    3     |

그에 따른 비선점형 우선순위 스케줄링의 간트차트는 다음과 같다.
![OS_Study_Image4](./img/OS_Study_Image4.jpg)

우선순위 스케줄링인데 비선점형으로 돌아갈 경우에는 한 번 실행한 프로세스는 중간에 뺏길 수 없기 때문에
우선순위는 높은데 실행시간이 길다면 비선점형의 특성으로 인해 다른 프로세스들이 기아상태에 빠질 수 있고
우선순위를 정하는 복잡한 알고리즘으로 인해 오버헤드가 크게 발생할 수 있다.

#### 2-2. 선점형 우선순위 스케줄링

위에서 사용했던 스케줄링 준비 큐는 그대로 사용한다고 하면 다음과 같은 간트차트가 생기게 된다.
![OS_Study_Image3.jpg](./img/OS_Study_Image5.jpg)

비선점 우선순위 스케줄링과는 다른점이 A 프로세스가 2초를 실행한 뒤 1초를 남기고
중간에 들어온 우선순위가 더 높은 F 프로세스에게 CPU 점유권을 넘겨준다는 점이다.
그래서 F 프로세스가 실행을 한 뒤 A 프로세스를 다시 실행한다.

그래서 평균대기시간과 평균반환시간을 비교해보면 선점형 우선순위 스케줄링이 훨씬 좋은 효율을
가지고 있음을 알 수 있다.

하지만 선점형은 Context Swiching(문맥 교환)이 일어나기 때문에 오버헤드가 발생하게 되고
우선순위가 빠른 프로세스가 계속 들어오게 되면 우선순위가 느린 프로세스는 계속
기아상태에 빠지게 된다.
이 문제를 해결하기 위해서는 오랫동안 실행되지 못한 프로세스에게는 가중치를 두는
Aging 기법을 사용해야 한다.