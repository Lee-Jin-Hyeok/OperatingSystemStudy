## RR [스케줄러 알고리즘]

RR은 선점형 알고리즘 중 하나로, 비선점형 스케줄링 알고리즘 중 FCFS의 단점을 보완하여
만든 스케줄러 알고리즘이 RR이다.

RR은 Round Robin의 약자로, 정해진 시간 할당량(TS, Time Slice)을 가지고
프로세스가 돌아가면서 CPU를 점유한다.
어떠한 프로세스가 CPU를 점유하고 나면 준비 큐의 가장 뒤로 들어간다.
따라서 순차적으로 CPU를 할당받는 이상적인 구조를 만들 수 있다.
그리고 모든 프로세스가 CPU를 일정시간마다 할당 받기 때문에
기아상태가 잘 일어나지 않는다.

이런 RR(Round Robin) 스케줄러 알고리즘에는 TS를 정하는 것이 가장 중요한데,
TS가 너무 크게 되면 프로세스가 자기가 할 일 다하고 종료하기 때문에
FCFS와 다를 게 없어지고,
TS가 너무 작게 되면 프로세스가 정상적인 실행을 못할뿐만 아니라
Context Swiching(문맥 교환)이 자주 일어나기 때문에 오버헤드가 발생하게 된다.
따라서 TS를 적절히 잘 정해야 한다.

### 1. RR 스케줄러 알고리즘 사용해보기

RR 스케줄러 알고리즘이 돌아가는 것을 확인하기 위해서는 준비 큐를 보고
간트차트를 그려보면 확실하게 알 수 있다.

다음은 RR 스케줄러를 위한 준비 큐이다.

| 프로세스 이름 | 도착시간 | 실행시간 |
| :-----------: | :------: | :------: |
|       A       |    0     |    24    |
|       B       |    5     |    7     |
|       C       |    10    |    16    |
|       D       |    18    |    5     |

RR 스케줄러 알고리즘을 돌리기 위해서는 반드시 시간 할당량이 존재해야 한다.
여기서는 시간 할당량을 5로 두겠다.

<img src="./img/OS_Study_Image8.jpg" alt="OS_Study_Image8" style="zoom: 80%;" />

그럼 이제부터는 위 준비 큐를 이용하여 위와 같은 간트차트를 만드는 과정을 하나부터 천천히 살펴볼 것이다.
많이 길어질 수 있으니 궁금하지 않다면 다음 챕터로 넘어가는 것을 권한다.

#### 1-1. 프로세스의 동작 과정

1.  0초가 되었을 때 준비 큐에 도착한 프로세스는 프로세스 A밖에 없으므로 프로세스 A를 실행한다.
    스케줄러 알고리즘이 RR이므로 시간 할당량인 5만큼만 실행하고 큐의 가장 뒤로 간다.
2.  5초가 되었을 때가 프로세스 A가 실행하여 끝나는 시간임과 동시에
    프로세스 B가 준비 큐에 도착하는 시간이다.
    이럴 경우 CPU에 따라서 어느 프로세스에 우선순위를 두는지가 다르게 되는데
    보통 새로 들어온 프로세스를 먼저 실행하는 형식으로 된다.
    따라서 실행을 막 끝낸 프로세스 A를 실행하기 보다는 방금 들어온 프로세스 B를 실행한다.
3.  프로세스 B도 시간 할당량인 5만큼 실행하여 10초가 된다.
    10초가 되었을 때는 프로세스 C가 준비 큐에 도착하므로 프로세스 C가 실행하는가 싶지만
    큐를 살펴보면 프로세스 A가 처음 실행함과 동시에 프로세스 B의 뒤쪽에 자리를 잡고 있었다.
    따라서 프로세스 B -> A -> C가 된다.
    여기서 프로세스가 들어왔다고 해서 먼저 우선순위를 갖는 것이 아니라
    새로 들어오게 되면 큐에 빨리 추가한다는 뜻으로 이해해야 한다.
4.  따라서 프로세스 A가 5동안 실행하여 15초가 되고 새로 들어온 프로세스가 없으므로
    프로세스 A의 다음 차례인 프로세스 C가 실행하게 된다.
    프로세스 C가 다 실행하게 되면 20초가 되는데
    18초에(위 그림에서는 안 보임) 프로세스 D가 도차하게 되어 프로세스 D가 C보다 앞자리에 차지하게 된다.
    따라서 순서는 프로세스 B -> A -> D -> C가 된다.
5.  프로세스 B의 차례가 와서 실행하였는데 프로세스 B의 실행시간이 다되어 프로세스 B는 큐에서 나가,
    프로세스 A -> D -> C의 순서가 된다.
6.  이 순서대로 계속 반복하면 결과가 나온다.

이렇게 간트차트를 만드는 방법과 그 과정에 대해서 알아보았다.
그러면 프로세스들의 대기시간과 반환시간 그리고 평균 대기시간과 평균 반환시간에 대해서 알아보아야 한다.

#### 1-2. 대기시간과 반환시간 구하기

어떠한 프로세스의 대기시간을 구할 때는 다음과 같은 공식을 사용한다.

```java
종료시간 - 도착시간 - 실행시간
```

따라서 각각의 프로세스는 다음과 같은 대기시간을 가지고 있다.

```java
프로세스 A : 51 - 0 - 24 = 27
프로세스 B : 22 - 5 - 7 = 10
프로세스 C : 52 - 10 - 16 = 26
프로세스 D : 32 - 18 - 5 = 9
```

평균 대기시간은 프로세스의 수로 나누면 되므로
(27 + 10 + 26 + 9)/4 = 18가 된다.

다음으로 프로세스의 반환시간을 구할 때는 다음과 같은 공식을 사용한다.

```java
종료시간 - 도착시간
```

따라서 각각의 프로세스는 다음과 같은 반환시간을 가지고 있다.

```java
프로세스 A : 51 - 0 = 51
프로세스 B : 22 - 5 = 17
프로세스 C : 20 - 10 = 10
프로세스 D : 32 - 18 = 14
```

평균 반환시간은 (51 + 17 + 10 + 14)/4 이므로 23이 된다.

### 2. RR의 특징

1.  RR은 같은 선점형 스케줄러 알고리즘인 SRT에 비하면 대기시간이나 반환시간이 현저히 떨어지지만
    프로세스의 대기시간을 보면 되게 비슷해서 공평한 것을 알 수 있다.
2.  모든 프로세스에게 CPU 할당을 하므로 기아 상태가 거의 일어나지 않는다.
3.  시간 할당량에 따라서 성능이 급격하게 차이난다.